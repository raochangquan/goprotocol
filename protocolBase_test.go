// 协议序列化和反序列的实现
// 作者 饶长泉
// 考虑到兼容各个平台,数值类型不使用变长类型 int 和uint
// string必须小于65536
// 考虑到其他平台的支持情况,目前只支持一维数组和切片
// 只会导出公有成员的数据,忽略私有成员
// 允许将结构体中的数组改为切片,若将切片成员改为数组,或将原数组长度改小.可以正常解析,但会丢失数据
// 一旦数据结构确定,只能在最后追加成员,不允许删除成员,允许修改成员名字,但不允许私有成员和公有成员互相转换
// 不支持成员为unsafe.Pointer,*interface{}对象
// 不支持interface成员中存放 数值和结构体外的类型,比如map,slic array
package protocol

import (
	"encoding/json"
	"reflect"
	"testing"
)

func BenchmarkMarshal(b *testing.B) {
	b.StopTimer()
	testobj := &TMapInfo{1001, "宝山路", 19, []TSlotData{{1, 1, false, 0, 0}, {5, 2, false, 0, 0}, {6, 2, false, 0, 0}}, 30, 5, 2, 1, 3, 3, 3, 5000}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		Marshal(testobj)
	}
}
func BenchmarkUnmarshal(b *testing.B) {
	b.StopTimer()
	testdata := []byte{153, 109, 140, 132, 30, 0, 130, 0, 233, 3, 0, 0, 9, 0, 229, 174, 157, 229, 177, 177, 232, 183, 175, 19, 0, 3, 0, 0, 0, 153, 109, 139, 132, 30, 0, 23, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153, 109, 139, 132, 30, 0, 23, 0, 5, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153, 109, 139, 132, 30, 0, 23, 0, 6, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 5, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 136, 19, 0, 0}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		Unmarshal(testdata)
	}
}
func TestMarshal(t *testing.T) {

	type TestMsg struct {
		A int
		B bool
		C uint16
		D int32
		E int64
		F float32
		G float64
		H []TSlotData
		I [2]TSlotData
		J []interface{}
		K [3]interface{}
		L [4]int64
		M []int16
		N *TSlotData
		O []*TSlotData
		Q interface{}
	}
	RegisterDataClass(ClassID_Test, (*TestMsg)(nil))
	testobj := TestMsg{1, true, 0xff, 0x7fffffff, -1, 1.1, 3.141592653, []TSlotData{{2, 2, false, 200, 200},
		{2, 2, true, 200, 200}}, [2]TSlotData{{3, 3, false, 300, 300},
		{4, 4, true, 400, 400}}, []interface{}{TSlotData{4, 4, true, 400, 400}}, [3]interface{}{TSlotData{4, 4, true, 400, 400}, TSlotData{444, 444, true, 44400, 44400}, TSlotData{4, 4, true, 400, 400}}, [4]int64{1, 0, -1, 1},
		[]int16{1, 2, 3}, new(TSlotData), []*TSlotData{&TSlotData{}, &TSlotData{6, 6, true, 6, 6}}, TSlotData{7, 7, true, 7, 7}}

	testdata := []byte{152, 109, 232, 3, 127, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 255, 0, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 255, 205, 204, 140, 63, 56, 233, 47, 84, 251, 33, 9, 64, 2, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 2, 0, 0, 0, 2, 0, 0, 200, 0, 0, 0, 200, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 2, 0, 0, 0, 2, 0, 1, 200, 0, 0, 0, 200, 0, 0, 0, 2, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 3, 0, 0, 0, 3, 0, 0, 44, 1, 0, 0, 44, 1, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 1, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 3, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 188, 1, 0, 0, 188, 1, 1, 112, 173, 0, 0, 112, 173, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 2, 0, 3, 0, 153, 109, 75, 66, 15, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 6, 0, 0, 0, 6, 0, 1, 6, 0, 0, 0, 6, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 7, 0, 0, 0, 7, 0, 1, 7, 0, 0, 0, 7, 0, 0, 0}

	type args struct {
		v interface{}
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{"TestMarshal1",
			args{testobj},
			testdata,
			false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Marshal(tt.args.v)
			if (err != nil) != tt.wantErr {
				t.Errorf("Marshal() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Marshal() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUnmarshal(t *testing.T) {

	type TestMsg struct {
		A int
		B bool
		C uint16
		D int32
		E int64
		F float32
		G float64
		H []TSlotData
		I [2]TSlotData
		J []interface{}
		K [3]interface{}
		L [4]int64
		M []int16
		N *TSlotData
		O []*TSlotData
		Q interface{}
	}
	RegisterDataClass(ClassID_Test, (*TestMsg)(nil))
	testobj := TestMsg{1, true, 0xff, 0x7fffffff, -1, 1.1, 3.141592653, []TSlotData{{2, 2, false, 200, 200},
		{2, 2, true, 200, 200}}, [2]TSlotData{{3, 3, false, 300, 300},
		{4, 4, true, 400, 400}}, []interface{}{TSlotData{4, 4, true, 400, 400}}, [3]interface{}{TSlotData{4, 4, true, 400, 400}, TSlotData{444, 444, true, 44400, 44400}, TSlotData{4, 4, true, 400, 400}}, [4]int64{1, 0, -1, 1},
		[]int16{1, 2, 3}, new(TSlotData), []*TSlotData{&TSlotData{}, &TSlotData{6, 6, true, 6, 6}}, TSlotData{7, 7, true, 7, 7}}

	//testdata := []byte{152, 109, 232, 3, 104, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 255, 0, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 255, 205, 204, 140, 63, 56, 233, 47, 84, 251, 33, 9, 64, 2, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 2, 0, 0, 0, 2, 0, 0, 200, 0, 0, 0, 200, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 2, 0, 0, 0, 2, 0, 1, 200, 0, 0, 0, 200, 0, 0, 0, 2, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 3, 0, 0, 0, 3, 0, 0, 44, 1, 0, 0, 44, 1, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 1, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 3, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 188, 1, 0, 0, 188, 1, 1, 112, 173, 0, 0, 112, 173, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 4, 0, 0, 0, 4, 0, 1, 144, 1, 0, 0, 144, 1, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 2, 0, 3, 0, 153, 109, 75, 66, 15, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153, 109, 75, 66, 15, 0, 23, 0, 6, 0, 0, 0, 6, 0, 1, 6, 0, 0, 0, 6, 0, 0, 0}
	testdata := []byte{152,109,232,3,127,1,1,0,0,0,0,0,0,0,1,255,0,255,255,255,127,255,255,255,255,255,255,255,255,205,204,140,63,56,233,47,84,251,33,9,64,2,0,0,0,153,109,75,66,15,0,23,0,2,0,0,0,2,0,0,200,0,0,0,200,0,0,0,153,109,75,66,15,0,23,0,2,0,0,0,2,0,1,200,0,0,0,200,0,0,0,2,0,0,0,153,109,75,66,15,0,23,0,3,0,0,0,3,0,0,44,1,0,0,44,1,0,0,153,109,75,66,15,0,23,0,4,0,0,0,4,0,1,144,1,0,0,144,1,0,0,1,0,0,0,153,109,75,66,15,0,23,0,4,0,0,0,4,0,1,144,1,0,0,144,1,0,0,3,0,0,0,153,109,75,66,15,0,23,0,4,0,0,0,4,0,1,144,1,0,0,144,1,0,0,153,109,75,66,15,0,23,0,188,1,0,0,188,1,1,112,173,0,0,112,173,0,0,153,109,75,66,15,0,23,0,4,0,0,0,4,0,1,144,1,0,0,144,1,0,0,4,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,0,3,0,0,0,1,0,2,0,3,0,153,109,75,66,15,0,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,153,109,75,66,15,0,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,153,109,75,66,15,0,23,0,6,0,0,0,6,0,1,6,0,0,0,6,0,0,0,153,109,75,66,15,0,23,0,7,0,0,0,7,0,1,7,0,0,0,7,0,0,0}
	type args struct {
		data []byte
	}
	tests := []struct {
		name    string
		args    args
		want    interface{}
		wantErr bool
	}{
		{"TestUnmarshal1", args{testdata}, &testobj, false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Unmarshal(tt.args.data)
			if (err != nil) != tt.wantErr {
				t.Errorf("Unmarshal() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			jsgot, _ := json.Marshal(got)
			jswang, _ := json.Marshal(tt.want)
			if !reflect.DeepEqual(jsgot, jswang) {
				t.Errorf("Unmarshal() = %s, want %s", jsgot, jswang)
			}
		})
	}
}
